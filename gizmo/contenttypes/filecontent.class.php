<?php
/**
 * FileContent class
 * 
 * Represents a piece of content taken from a file. Parses the file name 
 * for sorting number, 'tags' and extension(s) which helps determine which
 * sub-class to instantiate to handle this contents of the file and what
 * meta data to pass on to the template for displaying the files content.
 *
 * @package Web Gizmo
 * @author Alexander R B Whillas
 **/
abstract class FileContent
{
	/**
	 * @var SplFileInfo
	 * @see http://www.php.net/manual/en/class.splfileinfo.php
	 */
	protected $file = null;
	
	protected $extentions = array();

	function __construct($file)
	{
		// Clone beacuse this might be generated by an Iterator which destroys the object per interation.
//		$this->file = clone $file;
		// Clone no work in PHP < 5.3 
		$this->file = new SplFileInfo($file->getRealPath());
	}
	
	/**
	 * @see http://www.php.net/manual/en/directoryiterator.tostring.php
	 */
	function __toString()
	{
		// Cast object to a String to invoke its __toString() method.
		return (string) $this->get()->getFilename();
	}
	
	/**
	 * Invokes FileContent::render() when objects of type FileContent are called as functions.
	 * Sadly this only works in PHP 5.3 :(
	 * @see FileContent::render()
	 * @see http://www.php.net/manual/en/language.oop5.magic.php#language.oop5.magic.invoke
	 */
	public function __invoke($how = 'html', $format = 'xhtml1.1')
	{
		return $this->render($how, $format);
	}
	
	/**
	 * Get'er for the SplFileInfo object
	 *
	 * @return SplFileInfo Object
	 **/
	public function get()
	{
		return $this->file;
	}
	
	/**
	 * @return String	Filename without beginning number proceeded by an underscore nor the extension.
	 **/
	public function getCleanName()
	{	
		return FS::clean($this->get()->getBasename('.'.$this->getExtention()));
	}
	
	/**
	 * @return String	The file extension
	 **/
	public function getExtention()
	{
		return end(explode('.', $this->get()->getFilename()));
	}

	/**
	 * Polymorphic function for rendering the file content to a particular format.
	 * 
	 * @param	$how	The format to render. Supports 'html' (default), 'rss' and 'text' (plain text)
	 * @param	$format	
	 *
	 * @return String	In the appropriate format
	 * @todo Finish other rending formats i.e. RSS, plain text, RTF, PDF ... 
	 **/
	public function render($how = 'html', $format = 'xhtml1.1')
	{
		switch($how)
		{
			case 'text':
				return $this->text($format);
			
			case 'rss':
				return $this->rss($format);
				
			case 'html':
			default:
				return $this->html($format);
		}
	}

	/**
	 * HTML rendering
	 * @param	$format	The HTML standard to render to. This does nothing at the 
	 * 		moment but makes it future proof for HTML5 etc.
	 * @return String	HTML representation of the file.
	 */	
	abstract public function html($format = 'xhtml1.1');
	
//	abstract public function xml($format = 'xml1.0');
	
	/**
	 * Default text rendering
	 */
	public function text($format = 'utf8')
	{
		switch($format)
		{
			case 'utf8':
			default:
				// Force invoke __toString()
				return utf8_encode($this);
		}
	}
	
	/**
	 * Static Factory function which returns the appropriate 
	 * FileContent object for the given file object
	 *
	 * @param	$file	SplFileInfo
	 * @return	Object	of type FileContent
	 * @todo Would be nice to have this map externally so it could be configured on a per-site basis.
	 **/
	public static function Factory($file) 
	{
		if(!is_a($file, 'SplFileInfo'))
			return null;
		
		$extension = end(FileContent::getExtensions($file->getFilename()));

		$extension_class_map = array(
			'txt'		=> 'TextFileContent',
			'text'		=> 'MarkdownTextFileContent', // default generic markup extention

			// Markups
			'html'		=> 'HTMLFileContent',
			'htm'		=> 'HTMLFileContent',
//			'rtf'		=> 'RTFFileContent',
			'markdown'	=> 'MarkdownTextFileContent',
			'textile' 	=> 'TextileFileContent',

			// Images
			'jpg'		=> 'ImageFileContent',
			'jpeg'		=> 'ImageFileContent',
			'png'		=> 'ImageFileContent',
			'gif'		=> 'ImageFileContent',
			
			// Video
			'mov'		=> 'VideoFileContent',
			'mp4'		=> 'VideoFileContent',
			'3gp'		=> 'VideoFileContent',
			'ogv'		=> 'VideoFileContent',
			'mkv'		=> 'VideoFileContent',
			
			// Audio
			'ogg'		=> 'AudioFileContent',
			'oga'		=> 'AudioFileContent',
			'mp3'		=> 'AudioFileContent',
			'wav'		=> 'AudioFileContent',
			'spx'		=> 'AudioFileContent',
			
			'php'		=> 'PHPFileContent',
			
		);
		
		// If its an extention we know about
		if (array_key_exists($extension, $extension_class_map))
		{
			$ContentClass = $extension_class_map[$extension];

			return new $ContentClass($file);
		}
		else
		{
			if($file->isDir())
			{
				// its a Directory then make a link to it
				return new DirContent($file);
			}
			else
			{
				// else use the generic handler which is just a link to the file.
				return new GenericFileContent($file);
			}
		}
	}
	
	/**
	 * Gets a list of file extension for this file.
	 */
	function getExtensions($filename)
	{
		return explode('.', $filename);
	}
	
	/**
	 * Returns a Files virtual URL, that is relative to the virtual ?path=
	 * @return String	
	 **/
	function getURL()
	{		
		return FS::getURL(FS::getPath() . '/'. $this->get()->getFilename());
	}
	
	/**
	 * Direct link to the file in the _content_ Dir.
	 */
	function getFileURL()
	{
//		return CONTENT_DIR . FS::getPath() . '/'. $this->get()->getFilename();
//		return FS::getURL($this->get());
		
		// subtract the WEB_ROOT from the RealPath of the current file
		return BASE_URL_PATH.Path::open(WEB_ROOT, true)->from($this->get()->getRealPath());
		
//		return BASE_URL_PATH.FS::get()->contentRoot->from($this->get()->getRealPath());
	}
	
	/**
	 * @return 	Path object
	 */
	function getPath()
	{
		return Path::open($this->get());
	}
	
	/**
	 * Convert path/filename to CSS ID
	 */
	function cssID()
	{
	}
}